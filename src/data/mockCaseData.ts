import { Case, TaskStatus, NoteCategory, CaseStatus } from '../types';

// In-memory case store starts empty; will be populated through intake form
export const caseData: Case[] = [];

// Internal counters
let nextPrmNumber = 1;
let nextNprmNumber = 1;
let nextEntryId = 1;

function pad(num: number, size = 4) {
  return num.toString().padStart(size, '0');
}

export function generateSystemCaseId(isPrm: boolean): string {
  if (isPrm) {
    return `PRM-AFA-${pad(nextPrmNumber++)}`;
  } else {
    return `NPRM-AFA-${pad(nextNprmNumber++)}`;
  }
}

export function generateCaseName(first: string, last: string, employeeId: string) {
  return `${last}, ${first} ${employeeId}`;
}

export function getNextEntryId(): number {
  return nextEntryId++;
}

// Create a new case from intake minimal data
export function createCaseFromIntake(intake: {
  subject: { firstName: string; lastName: string; employeeId: string };
  incidentDate: Date;
  dateOfKnowledge: Date;
  concernType: string;
  contextTags: string[];
  description: string;
  witnesses: any[];
  urgencyLevel: 'low' | 'medium' | 'high';
  isPrmCase: boolean;
  foiNeeded: boolean;
  investigatorId?: string;
}): Case {
  const now = new Date();
  const baseInvestigationDays = 12; // placeholder SLA
  const investigationDeadline = new Date(now.getTime() + baseInvestigationDays * 24 * 60 * 60 * 1000);
  const closureDeadline = new Date(investigationDeadline.getTime() + 14 * 24 * 60 * 60 * 1000);

  const systemCaseId = generateSystemCaseId(intake.isPrmCase);
  const caseName = generateCaseName(intake.subject.firstName, intake.subject.lastName, intake.subject.employeeId);
  const entryId = getNextEntryId();

  const newCase: Case = {
    id: crypto.randomUUID(),
    systemCaseId,
    caseName,
    entryId,
    primaryCaseId: systemCaseId, // map for now
    secondaryCaseId: caseName.replace(' ', '-'),
    caseNumber: systemCaseId,
    employeeKey: intake.subject.employeeId,
    employeeFirstName: intake.subject.firstName,
    employeeLastName: intake.subject.lastName,
    employeeId: intake.subject.employeeId,
    unionGroup: null as any, // to be populated later
    violationType: null as any,
    severity: 0,
    likelihood: 0,
    status: CaseStatus.New,
    priority: intake.urgencyLevel === 'high' ? 'High' : intake.urgencyLevel === 'medium' ? 'Medium' : 'Low',
    dok: intake.dateOfKnowledge,
    incidentDate: intake.incidentDate,
    reportedDate: now,
    investigatorId: intake.investigatorId || 'TBD',
    assignedTo: undefined,
    baseLocation: null as any,
    riskScore: 0,
    litigationHold: false,
    description: intake.description,
    summary: undefined,
    investigationDeadline,
    closureDeadline,
    closeoutScheduled: false,
    eruCompleted: false,
    createdOn: now,
    createdBy: 'CURRENT_USER',
    modifiedOn: now,
    modifiedBy: 'CURRENT_USER',
    subjectEmployee: {
      id: intake.subject.employeeId,
      name: `${intake.subject.firstName} ${intake.subject.lastName}`,
      email: '',
      jobTitle: '',
      department: ''
    },
    dateOfKnowledge: intake.dateOfKnowledge,
    location: undefined,
    concernType: intake.concernType,
    contextTags: intake.contextTags,
    witnesses: intake.witnesses,
    urgencyLevel: intake.urgencyLevel,
    isPrmCase: intake.isPrmCase,
    foiNeeded: intake.foiNeeded,
    submitterId: 'CURRENT_USER',
    submitterInfo: undefined
  };
  caseData.push(newCase);
  return newCase;
}

export const getCases = (filters?: any, page = 1, pageSize = 10) => {
  let filteredCases = [...caseData];
  
  if (filters?.searchTerm) {
    const term = filters.searchTerm.toLowerCase();
    filteredCases = filteredCases.filter(c => 
      c.primaryCaseId.toLowerCase().includes(term) ||
      (c.description && c.description.toLowerCase().includes(term)) ||
      c.violationType.toLowerCase().includes(term) ||
      `${c.employeeFirstName} ${c.employeeLastName}`.toLowerCase().includes(term)
    );
  }
  
  const startIndex = (page - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  
  return {
    data: filteredCases.slice(startIndex, endIndex),
    total: filteredCases.length,
    page,
    pageSize
  };
};

export const getCaseById = (id: string) => {
  return caseData.find(c => c.id === id);
};

export const getTasksByCaseId = (caseId: string) => {
  // Mock tasks data
  return [
    {
      id: `task-${caseId}-1`,
      caseId,
      title: 'Conduct Initial Interview',
      description: 'Interview the reporting party',
      ownerId: 'owner1',
      assignedTo: 'investigator1',
      assignedBy: 'supervisor1',
      dueDate: new Date('2024-02-01'),
      status: TaskStatus.Pending,
      priority: 'High' as const,
      taskType: 'Interview',
      type: 'task' as const,
      autoGenerated: false,
      createdOn: new Date('2024-01-15'),
      createdBy: 'system'
    }
  ];
};

export const getNotesByCaseId = (caseId: string) => {
  // Mock notes data
  return [
    {
      id: `note-${caseId}-1`,
      caseId,
      authorId: 'investigator1',
      noteCategory: NoteCategory.General,
      subject: 'Initial Assessment',
      body: 'Initial case assessment completed with preliminary findings.',
      followUpFlag: false,
      isConfidential: false,
      createdOn: new Date('2024-01-15'),
      createdBy: 'investigator1'
    }
  ];
};

export const getTasks = (filters?: any) => {
  // Mock tasks for workspace
  const mockTasks = [
    {
      id: 'task-1',
      caseId: '1',
      title: 'Complete Case Review',
      description: 'Review case documentation and evidence',
      ownerId: 'owner1',
      assignedTo: filters?.assignedTo || 'user-1',
      assignedBy: 'supervisor1',
      dueDate: new Date('2024-02-01'),
      status: TaskStatus.Open,
      priority: 'High' as const,
      taskType: 'Review',
      type: 'task' as const,
      autoGenerated: false,
      createdOn: new Date('2024-01-15'),
      createdBy: 'system'
    }
  ];

  return {
    data: mockTasks,
    total: mockTasks.length
  };
};

export const getDashboardMetrics = () => {
  return {
    totalCases: caseData.length,
    activeCases: caseData.filter(c => c.status !== CaseStatus.Closed).length,
    overdueCases: 1,
    totalGrievances: 2,
    activeGrievances: 1,
    slaCompliance: 85,
    averageResolutionDays: 12,
    riskDistribution: {
      low: 2,
      medium: 1,
      high: 1,
      critical: 0
    }
  };
};
